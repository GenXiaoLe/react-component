{"ast":null,"code":"// vode => dom\n// render 接收vnode和传入的插入父节点 返回真实dom\n// 实现fiber\n// fiber tree数据结构是一种链表结构 除了常规的type props值。具体还有node(真实节点) child(第一个子元素) sibling(第一个子元素的下一个元素) base(上次的fiber节点 用于diff对比)\n// 1. 定义一个nextUnitOfWork，表示下一个任务单元，改造render方法 render方法接收最外层vnode tree，需要创建一个根fiber，并将其写入下一个任务单元，开启执行\n// 2. 使用调度栈方法requestIdleCallback，他可以自行分配任务时间，决定任务执行，我们只需把调度每个任务的方法或者diff传进去\n// 3. 创建调度任务方法workLoop\n// 4. workLoop写一个执行任务方法 performUnitOfWork 返回下一个任务nextUnitOfWork方便继续执行\n// 5. performUnitOfWork 执行当前任务 根据type类型 执行不同的方法 目的是生成当前fiber的真实dom 并且向下构建子元素的fiber结构\n// 6. 调用_createNode或者其它方式 生成当前fiber的真实dom 存在node属性中\n// 7. 调用reconcilerChildren 生成子元素的fiber结构 这里主要循环遍历所有子元素 根据元素的是否是同一个元素 判断需要更新还是创建fiber 还是删除 打上相应tags 并形成fiber链表结构方便之后调用\n// 8. performUnitOfWork 执行完当前任务 返回下一个任务 原则是先找子节点 如果没有去找兄弟节点 没有返回父节点在找兄弟节点 反复此步骤 直到所有节点均查找完毕 返回false\n// 9. workLoop写一个任务结束后提交任务，执行渲染的方法commitRoot 目的是当所有单元任务均执行完毕之后 统一提交进行更新渲染 插入相应dom中完成更新\n// 10. commitWorker方法用来提交单元任务 第一次接收根fiber\n// 11. 先找到父节点 方便之后创建或更新使用，根据之前fiber中的tags 创建元素 或 更新元素 或 删除元素，实行完当前的元素操作 对他的child和sibling也进行commitWorker\n// 12. 最后在fiber不存在时候表明所有元素均执行完毕 至此fiber diff 以及 渲染全部结束\n// 写一个数据演示fiber结构\n// {\n//     type: 'element', fiber类型\n//     node: null, 本fiber的真实DOM\n//     base: null, 上一个fiber 用于diff\n//     props: {}, vode收到的props\n//     parent: null, 父节点\n//     child: {}, 第一个子节点\n//     sibling: {} 子节点的兄弟元素\n//     effectTag: '' 节点的状态\n// }\nimport { PLACEMENT, UPDATE } from './component/CONSTS'; // 表示下一个单元任务\n\nlet nextUnitOfWork; // 表示根fiber\n\nlet wipRoot; // 表示当前的根节点\n\nlet currentRoot; // 表示当前工作的fiber\n\nlet wipFiber; // 当前hooks的深度\n\nlet hookIndex; // 虚拟dom转化为真实dom\n\nfunction render(vnode, container) {\n  // 创建根fiber 根fiber是container 他的子元素是里面的vndoe\n  wipRoot = {\n    node: container,\n    props: {\n      children: [vnode]\n    },\n    base: currentRoot\n  }; // 赋值给下一个任务单元 以开启任务执行\n\n  nextUnitOfWork = wipRoot;\n} // 创建节点\n\n\nfunction _createNode(vnode) {\n  const {\n    type,\n    props\n  } = vnode;\n  let node; // 如果vnode是文本节点\n\n  if (type === 'Text') {\n    node = document.createTextNode('');\n  } else if (type) {\n    // 如果是元素节点\n    node = document.createElement(type);\n  } // 将属性填充进节点中\n\n\n  _updateNode(node, props);\n\n  return node;\n} // 接收正在工作的fiber以及子节点数组 构建子节点fiber\n\n\nfunction reconcilerChildren(workInProgressFiber, children) {\n  // 上次的子fiber 用于判断是否是否是同一个fiber 来判断更新或者新增 主要用于diff base主要用来存储之前的fiber\n  let oldChildFiber = workInProgressFiber.base && workInProgressFiber.base.child; // 上一个fiber 主要用来形成链表sibing使用\n\n  let prevFiber = null; // 循环children创建fiber\n\n  for (let i = 0; i < children.length; i++) {\n    let child = children[i]; // 这里先不考虑key值 是否是相同的fiber\n\n    let isSameType = oldChildFiber && child && oldChildFiber.type === child.type; // 构建fiber\n\n    let newFiber;\n\n    if (isSameType && child) {\n      console.log(isSameType); // 相同打上更新的tags\n\n      newFiber = {\n        type: oldChildFiber.type,\n        props: oldChildFiber.props,\n        node: oldChildFiber.node,\n        base: oldChildFiber,\n        parent: workInProgressFiber,\n        effectTag: UPDATE\n      };\n    } else if (!isSameType && child) {\n      // 创建新的fiber\n      // 相同打上新增的tags\n      newFiber = {\n        type: child.type,\n        props: child.props,\n        node: null,\n        // 新增的fiber没有真实dom\n        base: null,\n        // 新增的fiber没有上次fiber\n        parent: workInProgressFiber,\n        effectTag: PLACEMENT // tags为新增\n\n      };\n    }\n\n    if (oldChildFiber) {\n      // 如果oldChildFiber存在，则把他赋值为他的兄弟元素 方便下次循环使用\n      oldChildFiber = oldChildFiber.sibling;\n    } // 生成链表结构\n\n\n    if (i === 0) {\n      // 第一次循环fiber-child就是第一个子元素\n      workInProgressFiber.child = newFiber;\n    } else {\n      // 不是第一次循环则是他的兄弟元素\n      prevFiber.sibling = newFiber;\n    } // 把newFiber赋值给prevFiber这样和165行配合则可以生成链表 -> a1: { sibling: a2 : { sibling: a3 } }\n\n\n    prevFiber = newFiber;\n  } // 循环结束后 所有fiber树构建完成 是否是新增的数据也打上了标签\n\n} // 接收dom以及props，进行赋值\n\n\nfunction _updateNode(node, values) {\n  Object.keys(values).filter(item => item !== 'children').forEach(key => {\n    if (key.slice(0, 2) === 'on') {\n      let _typeName = key.slice(2).toLocaleLowerCase();\n\n      document.addEventListener(_typeName, values[key]);\n    } else {\n      node[key] = values[key];\n    }\n  });\n} // 创建class节点\n\n\nfunction _createComNode(fiber) {\n  const {\n    type,\n    props\n  } = fiber;\n  let comp = new type(props);\n  let children = [comp.render()];\n  reconcilerChildren(fiber, children);\n} // 创建function节点\n\n\nfunction _createFnNode(fiber) {\n  // 如果当前运行的fiber是个funtion组件 需要给当前的fiber重置创建一个hooks属性 并要把hook下标重置\n  wipFiber = fiber;\n  wipFiber.hooks = [];\n  hookIndex = 0;\n  const {\n    type,\n    props\n  } = fiber;\n  let children = [type(props)];\n  reconcilerChildren(fiber, children);\n} // 其他元素节点\n\n\nfunction _createElement(fiber) {\n  // 如果node不存在则创建一个node\n  if (!fiber.node) {\n    fiber.node = _createNode(fiber);\n  }\n\n  const {\n    children\n  } = fiber.props;\n  reconcilerChildren(fiber, children);\n} // 创建子节点的fiber\n\n\nfunction _createFragment(fiber) {\n  const {\n    children\n  } = fiber.props;\n  reconcilerChildren(fiber, children);\n} // 接收任务 并执行任务\n\n\nfunction performUnitOfWork(fiber) {\n  // 执行当前的任务\n  const {\n    type\n  } = fiber;\n\n  if (typeof type === 'function') {\n    type.prototype.isReactComponent ? _createComNode(fiber) : _createFnNode(fiber);\n  } else if (type) {\n    // 如果是元素节点\n    _createElement(fiber);\n  } else {\n    // 如果没有type 一般是根元素或者Fragment\n    _createFragment(fiber);\n  } // 执行完当前的任务 需要返回下一个任务\n  // 如果child成功构建 说明有子元素，按照子元素优先的原则 先返回子元素\n\n\n  if (fiber.child) {\n    return fiber.child;\n  } // 如果child不存在 则说明没有子元素，那就去查找兄弟元素\n\n\n  let nextFiber = fiber; // 循环查找 如果兄弟元素存在 则返回兄弟元素 不存在则返回父元素继续查找兄弟元素 直到找到或者所有元素不存在为止\n\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling;\n    }\n\n    nextFiber = nextFiber.parent;\n  }\n\n  return null;\n} // 创建hooks\n// 每个fiber上新增一个属性hooks数组，用来存放hooks，所有的hooks都在里面\n\n\nexport function useState(init) {\n  // 如果存在一个旧的hook 则需要从当前工作的fiber中找出这个hook\n  let oldHook = wipFiber.base && wipFiber.base.hooks[hookIndex]; // 创建一个 hook 用来存放state以及每次更新的数组\n\n  let hook = {\n    state: oldHook ? oldHook.state : init,\n    // 当前hook的state\n    queue: [] // 当前hook更新的数组 即当前hook的执行数组 长度即执行了几次\n\n  }; // 找出hook中执行数组\n\n  const actions = oldHook ? oldHook.queue : []; // 将最后一次执行的state 赋值给hook\n\n  actions.forEach(action => {\n    hook.state = action;\n  }); // 渲染setState\n\n  let setState = action => {\n    // 将action push进queue中 比如state + 1;\n    hook.queue.push(action); // 创建wipRoot 将其加入调用栈 然后执行 即从当前节点开始执行\n\n    wipRoot = {\n      node: currentRoot.node,\n      props: currentRoot.props,\n      base: currentRoot\n    }; // 将下一个任务单元设置为当前赋值后的任务\n\n    nextUnitOfWork = wipRoot;\n  }; // 将当前拼装好的hook push入当前工作fiber的hooks中 之后在调用useState的时候能够取到该hook\n\n\n  wipFiber.hooks.push(hook); // 之后hookIndex +1\n\n  hookIndex++;\n  return [hook.state, setState];\n}\n\nfunction commitWorker(fiber) {\n  // 如果fiber不存在则退出\n  if (!fiber) {\n    return;\n  } // 找出父节点的fiber\n\n\n  let parentNodeFiber = fiber.parent; // 如果父节点的node不存在 则向上找父元素\n\n  while (!parentNodeFiber.node) {\n    parentNodeFiber = parentNodeFiber.parent;\n  } // 拿出真实父节点DOM\n\n\n  const parentNode = parentNodeFiber.node;\n\n  if (fiber.effectTag === PLACEMENT && fiber.node !== null) {\n    // 如果当前节点是一个新节点，则直接插入\n    parentNode.appendChild(fiber.node);\n  } else if (fiber.effectTag === UPDATE && fiber.node !== null) {\n    // 如果当前节点是一个旧节点，则需要先进行一遍赋值\n    _updateNode(fiber.node, fiber.props);\n  } // 当前节点执行完，需要继续执行他的子节点和子节点的兄弟节点\n\n\n  commitWorker(fiber.child);\n  commitWorker(fiber.sibling);\n}\n\nfunction commitRoot() {\n  // 提交fiber tree上所有的节点 从root开始\n  commitWorker(wipRoot.child); // 记录当前工作的根节点\n\n  currentRoot = wipRoot; // 清空wipRoot 防止反复调用\n\n  wipRoot = null;\n} // 创建任务调度方法 调度diff或者是渲染任务 接收一个传入的deadline值 表示任务剩余时间\n\n\nfunction workLoop(deadline) {\n  // 循环调度执行所有任务 规则是有下一个任务并且循环时间尚未结束\n  while (nextUnitOfWork && deadline.timeRemaining() > 1) {\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n  } // 执行完所有的任务，需要统一提交，渲染并插入到真实的dom节点中\n\n\n  if (!nextUnitOfWork && wipRoot) {\n    commitRoot();\n  }\n}\n\nrequestIdleCallback(workLoop);\nexport default {\n  render\n};","map":{"version":3,"sources":["/Users/hanyue/development/github/react-components/src/plugins/KReactDOM.fiber.js"],"names":["PLACEMENT","UPDATE","nextUnitOfWork","wipRoot","currentRoot","wipFiber","hookIndex","render","vnode","container","node","props","children","base","_createNode","type","document","createTextNode","createElement","_updateNode","reconcilerChildren","workInProgressFiber","oldChildFiber","child","prevFiber","i","length","isSameType","newFiber","console","log","parent","effectTag","sibling","values","Object","keys","filter","item","forEach","key","slice","_typeName","toLocaleLowerCase","addEventListener","_createComNode","fiber","comp","_createFnNode","hooks","_createElement","_createFragment","performUnitOfWork","prototype","isReactComponent","nextFiber","useState","init","oldHook","hook","state","queue","actions","action","setState","push","commitWorker","parentNodeFiber","parentNode","appendChild","commitRoot","workLoop","deadline","timeRemaining","requestIdleCallback"],"mappings":"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","sourcesContent":["// vode => dom\n// render 接收vnode和传入的插入父节点 返回真实dom\n\n// 实现fiber\n// fiber tree数据结构是一种链表结构 除了常规的type props值。具体还有node(真实节点) child(第一个子元素) sibling(第一个子元素的下一个元素) base(上次的fiber节点 用于diff对比)\n// 1. 定义一个nextUnitOfWork，表示下一个任务单元，改造render方法 render方法接收最外层vnode tree，需要创建一个根fiber，并将其写入下一个任务单元，开启执行\n// 2. 使用调度栈方法requestIdleCallback，他可以自行分配任务时间，决定任务执行，我们只需把调度每个任务的方法或者diff传进去\n// 3. 创建调度任务方法workLoop\n// 4. workLoop写一个执行任务方法 performUnitOfWork 返回下一个任务nextUnitOfWork方便继续执行\n// 5. performUnitOfWork 执行当前任务 根据type类型 执行不同的方法 目的是生成当前fiber的真实dom 并且向下构建子元素的fiber结构\n// 6. 调用_createNode或者其它方式 生成当前fiber的真实dom 存在node属性中\n// 7. 调用reconcilerChildren 生成子元素的fiber结构 这里主要循环遍历所有子元素 根据元素的是否是同一个元素 判断需要更新还是创建fiber 还是删除 打上相应tags 并形成fiber链表结构方便之后调用\n// 8. performUnitOfWork 执行完当前任务 返回下一个任务 原则是先找子节点 如果没有去找兄弟节点 没有返回父节点在找兄弟节点 反复此步骤 直到所有节点均查找完毕 返回false\n// 9. workLoop写一个任务结束后提交任务，执行渲染的方法commitRoot 目的是当所有单元任务均执行完毕之后 统一提交进行更新渲染 插入相应dom中完成更新\n// 10. commitWorker方法用来提交单元任务 第一次接收根fiber\n// 11. 先找到父节点 方便之后创建或更新使用，根据之前fiber中的tags 创建元素 或 更新元素 或 删除元素，实行完当前的元素操作 对他的child和sibling也进行commitWorker\n// 12. 最后在fiber不存在时候表明所有元素均执行完毕 至此fiber diff 以及 渲染全部结束\n\n// 写一个数据演示fiber结构\n// {\n//     type: 'element', fiber类型\n//     node: null, 本fiber的真实DOM\n//     base: null, 上一个fiber 用于diff\n//     props: {}, vode收到的props\n//     parent: null, 父节点\n//     child: {}, 第一个子节点\n//     sibling: {} 子节点的兄弟元素\n//     effectTag: '' 节点的状态\n// }\n\nimport { PLACEMENT, UPDATE } from './component/CONSTS'\n\n// 表示下一个单元任务\nlet nextUnitOfWork;\n// 表示根fiber\nlet wipRoot;\n// 表示当前的根节点\nlet currentRoot;\n// 表示当前工作的fiber\nlet wipFiber;\n// 当前hooks的深度\nlet hookIndex;\n\n// 虚拟dom转化为真实dom\nfunction render(vnode, container) {\n    // 创建根fiber 根fiber是container 他的子元素是里面的vndoe\n    wipRoot = {\n        node: container,\n        props: {children: [vnode]},\n        base: currentRoot\n    }\n    // 赋值给下一个任务单元 以开启任务执行\n    nextUnitOfWork = wipRoot;\n}\n\n// 创建节点\nfunction _createNode(vnode) {\n    const { type, props } = vnode;\n    let node;\n    // 如果vnode是文本节点\n    if (type === 'Text') {\n        node = document.createTextNode('');\n    } else if (type) {\n        // 如果是元素节点\n        node = document.createElement(type);\n    }\n\n    // 将属性填充进节点中\n    _updateNode(node, props);\n\n    return node;\n}\n\n// 接收正在工作的fiber以及子节点数组 构建子节点fiber\nfunction reconcilerChildren(workInProgressFiber, children) {\n    // 上次的子fiber 用于判断是否是否是同一个fiber 来判断更新或者新增 主要用于diff base主要用来存储之前的fiber\n    let oldChildFiber =  workInProgressFiber.base && workInProgressFiber.base.child;\n\n    // 上一个fiber 主要用来形成链表sibing使用\n    let prevFiber = null;\n\n    // 循环children创建fiber\n    for (let i = 0; i < children.length; i++) {\n        let child = children[i];\n        // 这里先不考虑key值 是否是相同的fiber\n        let isSameType = oldChildFiber && child && oldChildFiber.type === child.type;\n\n        // 构建fiber\n        let newFiber;\n        if (isSameType && child) {\n            console.log(isSameType);\n            // 相同打上更新的tags\n            newFiber = {\n                type: oldChildFiber.type,\n                props: oldChildFiber.props,\n                node: oldChildFiber.node,\n                base: oldChildFiber,\n                parent: workInProgressFiber,\n                effectTag: UPDATE\n            }\n        } else if (!isSameType && child) {\n            // 创建新的fiber\n            // 相同打上新增的tags\n            newFiber = {\n                type: child.type,\n                props: child.props,\n                node: null, // 新增的fiber没有真实dom\n                base: null, // 新增的fiber没有上次fiber\n                parent: workInProgressFiber,\n                effectTag: PLACEMENT // tags为新增\n            }\n        }\n\n        if (oldChildFiber) {\n            // 如果oldChildFiber存在，则把他赋值为他的兄弟元素 方便下次循环使用\n            oldChildFiber = oldChildFiber.sibling;\n        }\n\n        // 生成链表结构\n        if (i === 0) {\n            // 第一次循环fiber-child就是第一个子元素\n            workInProgressFiber.child = newFiber;\n        } else {\n            // 不是第一次循环则是他的兄弟元素\n            prevFiber.sibling = newFiber;\n        }\n        // 把newFiber赋值给prevFiber这样和165行配合则可以生成链表 -> a1: { sibling: a2 : { sibling: a3 } }\n        prevFiber = newFiber;\n    }\n\n    // 循环结束后 所有fiber树构建完成 是否是新增的数据也打上了标签\n}\n\n// 接收dom以及props，进行赋值\nfunction _updateNode(node, values) {\n    Object.keys(values)\n        .filter(item => item !== 'children')\n        .forEach(key => {\n            if (key.slice(0, 2) === 'on') {\n                let _typeName = key.slice(2).toLocaleLowerCase();\n                document.addEventListener(_typeName, values[key]);\n            } else {\n                node[key] = values[key];\n            }\n        })\n}\n\n// 创建class节点\nfunction _createComNode(fiber) {\n    const { type, props } = fiber;\n    let comp = new type(props);\n    let children = [comp.render()];\n    reconcilerChildren(fiber, children);\n}\n\n// 创建function节点\nfunction _createFnNode(fiber) {\n    // 如果当前运行的fiber是个funtion组件 需要给当前的fiber重置创建一个hooks属性 并要把hook下标重置\n    wipFiber = fiber;\n    wipFiber.hooks = [];\n    hookIndex = 0;\n\n    const { type, props } = fiber;\n    let children = [type(props)];\n    reconcilerChildren(fiber, children);\n}\n\n// 其他元素节点\nfunction _createElement(fiber) {\n    // 如果node不存在则创建一个node\n    if (!fiber.node) {\n        fiber.node = _createNode(fiber);\n    }\n    const { children } = fiber.props;\n    reconcilerChildren(fiber, children);\n}\n\n// 创建子节点的fiber\nfunction _createFragment(fiber) {\n    const { children } = fiber.props;\n    reconcilerChildren(fiber, children);\n}\n\n// 接收任务 并执行任务\nfunction performUnitOfWork(fiber) {\n    // 执行当前的任务\n    const { type } = fiber;\n    if (typeof type === 'function') {\n        type.prototype.isReactComponent\n            ? _createComNode(fiber)\n            : _createFnNode(fiber);\n    } else if (type) {\n        // 如果是元素节点\n        _createElement(fiber);\n    } else {\n        // 如果没有type 一般是根元素或者Fragment\n        _createFragment(fiber)\n    }\n\n    // 执行完当前的任务 需要返回下一个任务\n    // 如果child成功构建 说明有子元素，按照子元素优先的原则 先返回子元素\n    if (fiber.child) {\n        return fiber.child;\n    }\n    // 如果child不存在 则说明没有子元素，那就去查找兄弟元素\n    let nextFiber = fiber;\n    // 循环查找 如果兄弟元素存在 则返回兄弟元素 不存在则返回父元素继续查找兄弟元素 直到找到或者所有元素不存在为止\n    while (nextFiber) {\n        if (nextFiber.sibling) {\n            return nextFiber.sibling;\n        }\n        nextFiber = nextFiber.parent;\n    }\n\n    return null;\n}\n\n// 创建hooks\n// 每个fiber上新增一个属性hooks数组，用来存放hooks，所有的hooks都在里面\nexport function useState(init) {\n    // 如果存在一个旧的hook 则需要从当前工作的fiber中找出这个hook\n    let oldHook = wipFiber.base && wipFiber.base.hooks[hookIndex];\n\n    // 创建一个 hook 用来存放state以及每次更新的数组\n    let hook = {\n        state: oldHook ? oldHook.state : init, // 当前hook的state\n        queue: [] // 当前hook更新的数组 即当前hook的执行数组 长度即执行了几次\n    }\n\n    // 找出hook中执行数组\n    const actions = oldHook ? oldHook.queue : [];\n\n    // 将最后一次执行的state 赋值给hook\n    actions.forEach(action => {\n        hook.state = action;\n    });\n\n    // 渲染setState\n    let setState = action => {\n        // 将action push进queue中 比如state + 1;\n        hook.queue.push(action);\n\n        // 创建wipRoot 将其加入调用栈 然后执行 即从当前节点开始执行\n        wipRoot = {\n            node: currentRoot.node,\n            props: currentRoot.props,\n            base: currentRoot\n        }\n\n        // 将下一个任务单元设置为当前赋值后的任务\n        nextUnitOfWork = wipRoot;\n    };\n\n    // 将当前拼装好的hook push入当前工作fiber的hooks中 之后在调用useState的时候能够取到该hook\n    wipFiber.hooks.push(hook);\n    // 之后hookIndex +1\n    hookIndex++;\n\n    return [hook.state, setState];\n}\n\nfunction commitWorker(fiber) {\n    // 如果fiber不存在则退出\n    if (!fiber) {\n        return;\n    }\n\n    // 找出父节点的fiber\n    let parentNodeFiber = fiber.parent;\n    // 如果父节点的node不存在 则向上找父元素\n    while(!parentNodeFiber.node) {\n        parentNodeFiber = parentNodeFiber.parent;\n    }\n    // 拿出真实父节点DOM\n    const parentNode = parentNodeFiber.node;\n\n    if (fiber.effectTag === PLACEMENT && fiber.node !== null) {\n        // 如果当前节点是一个新节点，则直接插入\n        parentNode.appendChild(fiber.node);\n    } else if (fiber.effectTag === UPDATE && fiber.node !== null) {\n        // 如果当前节点是一个旧节点，则需要先进行一遍赋值\n        _updateNode(fiber.node, fiber.props);\n    }\n\n    // 当前节点执行完，需要继续执行他的子节点和子节点的兄弟节点\n    commitWorker(fiber.child);\n    commitWorker(fiber.sibling);\n\n}\n\nfunction commitRoot() {\n    // 提交fiber tree上所有的节点 从root开始\n    commitWorker(wipRoot.child);\n    // 记录当前工作的根节点\n    currentRoot = wipRoot;\n    // 清空wipRoot 防止反复调用\n    wipRoot = null;\n}\n\n\n// 创建任务调度方法 调度diff或者是渲染任务 接收一个传入的deadline值 表示任务剩余时间\nfunction workLoop(deadline) {\n    // 循环调度执行所有任务 规则是有下一个任务并且循环时间尚未结束\n    while(nextUnitOfWork && deadline.timeRemaining() > 1) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n\n    // 执行完所有的任务，需要统一提交，渲染并插入到真实的dom节点中\n    if (!nextUnitOfWork && wipRoot) {\n        commitRoot();\n    }\n}\n\nrequestIdleCallback(workLoop);\n\nexport default {\n    render\n}"]},"metadata":{},"sourceType":"module"}