{"ast":null,"code":"var _jsxFileName = \"/Users/hanyue/development/github/react-components/src/plugins/KRouter.js\";\n// 组件目标\n// 实现BrowserRouter\n// 1.将children传出\n// 2.link需要动态更新history，利用上下文context传出\n// 实现Route\n// 1. 接收两个参数 path 和 component\n// 2. 利用上下文接收history并动态更新组件\n// 3. 利用函数生成match，匹配到的话，拼装location，mactch，context，传入并根据类型生成组件\n// 4. 根据优先级children component render\n// 实现Link\n// 1.返回一个a标签 接收 to 和 children两个参数\n// 2.为了避免a标签切换界面闪屏，点击时候利用history跳转\n// 3.为了保证动态更新和一致性，使用同一个history，从父组件BrowserRouter中传下来\n// 实现switch\n// 1. 接收上下文，之后在path没有传入时候，接收默认match，一般404会用到 或者location，在匹配match会用到\n// 2. 遍历找出匹配到的第一个元素，使用createClone返回\n// 实现Redirect \nimport React, { Component } from 'react';\nimport { createBrowserHistory } from 'history';\nimport matchPath from './matchPath';\nconst RouterContext = React.createContext();\n\nclass BrowserRouter extends Component {\n  static computeRootMatch(pathname) {\n    return {\n      path: \"/\",\n      url: \"/\",\n      params: {},\n      isExact: pathname === \"/\"\n    };\n  }\n\n  constructor(props) {\n    super(props);\n    this.history = createBrowserHistory();\n    this.state = {\n      location: this.history.location\n    }; // 当history变化时候监听并改变\n\n    this.unListen = this.history.listen(location => {\n      this.setState({\n        location\n      });\n    });\n  }\n\n  componentWillUnmount() {\n    if (this.unListen) {\n      this.unListen();\n    }\n  }\n\n  render() {\n    return React.createElement(RouterContext.Provider, {\n      value: {\n        history: this.history,\n        location: this.state.location,\n        match: BrowserRouter.computeRootMatch(this.state.location.pathname)\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 52\n      },\n      __self: this\n    }, this.props.children);\n  }\n\n}\n\nclass Route extends Component {\n  render() {\n    return React.createElement(RouterContext.Consumer, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 66\n      },\n      __self: this\n    }, context => {\n      const {\n        children,\n        component,\n        render,\n        computeMatch\n      } = this.props; // props中的location优先级更高\n\n      const location = this.props.location || context.location;\n      const match = matchPath(location.pathname, this.props);\n      const props = { ...context,\n        location,\n        match\n      };\n      console.log('Route', computeMatch, this.props); // 由于存在嵌套和路由守卫之类的方式，需要  更新上下文，所以需要再包一层上下文，使他始终接受的都是上一层的上下文\n\n      return React.createElement(RouterContext.Provider, {\n        value: props,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 79\n        },\n        __self: this\n      }, match ? children ? typeof children === 'function' ? children(props) : children : component ? React.createElement(component, props) : render ? render(props) : null : typeof children === 'function' ? children(props) : null);\n    });\n  }\n\n}\n\nclass Link extends Component {\n  constructor(...args) {\n    super(...args);\n\n    this.handleClick = (event, history) => {\n      event.preventDefault();\n      history.push(this.props.to);\n    };\n  }\n\n  render() {\n    const {\n      to,\n      children\n    } = this.props;\n    return React.createElement(RouterContext.Consumer, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 101\n      },\n      __self: this\n    }, context => {\n      return React.createElement(\"a\", {\n        href: to,\n        onClick: event => this.handleClick(event, context.history),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 103\n        },\n        __self: this\n      }, children);\n    });\n  }\n\n}\n\nclass Switch extends Component {\n  render() {\n    return React.createElement(RouterContext.Consumer, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 112\n      },\n      __self: this\n    }, context => {\n      const location = this.props.location || context.location;\n      let element, match; // 拿出传入children\n\n      const {\n        children\n      } = this.props; // 遍历查找第一个匹配得到的元素 也就是match不存在并且是合法dom\n\n      React.Children.forEach(children, child => {\n        if (match == null && React.isValidElement(child)) {\n          element = child;\n          const path = child.props.path;\n          match = context.match ? context.match : path ? matchPath(location.pathname, { ...child.props,\n            path\n          }) : null;\n        }\n      });\n      return match ? React.cloneElement(element, {\n        location,\n        computeMatch: match\n      }) : null;\n    });\n  }\n\n}\n\nclass Redirect extends Component {\n  render() {\n    return React.createElement(RouterContext.Consumer, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 138\n      },\n      __self: this\n    }, context => {\n      const {\n        to\n      } = this.props;\n      const {\n        history\n      } = context;\n      console.log('to', to);\n      return React.createElement(LifeCycle, {\n        onMount: () => history.push(to),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 144\n        },\n        __self: this\n      });\n    });\n  }\n\n}\n\nclass LifeCycle extends Component {\n  componentDidMount() {\n    if (this.props.onMount) {\n      this.props.onMount();\n    }\n  }\n\n  render() {\n    return null;\n  }\n\n}\n\nexport { BrowserRouter, Route, Link, Switch, Redirect };","map":{"version":3,"sources":["/Users/hanyue/development/github/react-components/src/plugins/KRouter.js"],"names":["React","Component","createBrowserHistory","matchPath","RouterContext","createContext","BrowserRouter","computeRootMatch","pathname","path","url","params","isExact","constructor","props","history","state","location","unListen","listen","setState","componentWillUnmount","render","match","children","Route","context","component","computeMatch","console","log","createElement","Link","handleClick","event","preventDefault","push","to","Switch","element","Children","forEach","child","isValidElement","cloneElement","Redirect","LifeCycle","componentDidMount","onMount"],"mappings":"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","sourcesContent":["// 组件目标\n// 实现BrowserRouter\n// 1.将children传出\n// 2.link需要动态更新history，利用上下文context传出\n// 实现Route\n// 1. 接收两个参数 path 和 component\n// 2. 利用上下文接收history并动态更新组件\n// 3. 利用函数生成match，匹配到的话，拼装location，mactch，context，传入并根据类型生成组件\n// 4. 根据优先级children component render\n// 实现Link\n// 1.返回一个a标签 接收 to 和 children两个参数\n// 2.为了避免a标签切换界面闪屏，点击时候利用history跳转\n// 3.为了保证动态更新和一致性，使用同一个history，从父组件BrowserRouter中传下来\n// 实现switch\n// 1. 接收上下文，之后在path没有传入时候，接收默认match，一般404会用到 或者location，在匹配match会用到\n// 2. 遍历找出匹配到的第一个元素，使用createClone返回\n// 实现Redirect \n\nimport React, { Component } from 'react';\nimport { createBrowserHistory } from 'history';\nimport matchPath from './matchPath';\n\nconst RouterContext = React.createContext();\n\nclass BrowserRouter extends Component {\n    static computeRootMatch(pathname) {\n        return { path: \"/\", url: \"/\", params: {}, isExact: pathname === \"/\" };\n    }\n\n    constructor(props) {\n        super(props);\n        this.history = createBrowserHistory();\n        this.state = {\n            location: this.history.location\n        };\n        // 当history变化时候监听并改变\n        this.unListen = this.history.listen(location => {\n            this.setState({\n                location\n            })\n        });\n    }\n\n    componentWillUnmount() {\n        if (this.unListen) {\n            this.unListen();\n        }\n    }\n\n    render() {\n        return (\n            <RouterContext.Provider value={{\n                history: this.history, \n                location: this.state.location,\n                match: BrowserRouter.computeRootMatch(this.state.location.pathname)\n            }}>\n                {this.props.children}\n            </RouterContext.Provider>\n        )\n    }\n}\n\nclass Route extends Component {\n    render() {\n        return (\n            <RouterContext.Consumer>{\n                context => {\n                    const { children, component, render, computeMatch } = this.props;\n                    // props中的location优先级更高\n                    const location = this.props.location || context.location;\n                    const match = matchPath(location.pathname, this.props);\n                    const props = {\n                        ...context,\n                        location,\n                        match\n                    };\n                    console.log('Route', computeMatch, this.props);\n                    // 由于存在嵌套和路由守卫之类的方式，需要  更新上下文，所以需要再包一层上下文，使他始终接受的都是上一层的上下文\n                    return <RouterContext.Provider value={props}>\n                        { match ? \n                        children ? typeof children === 'function' ? children(props) : children\n                        : component ? React.createElement(component, props)\n                        : render ? render(props) : null\n                        : typeof children === 'function' ? children(props) : null }\n                    </RouterContext.Provider>\n                }\n            }</RouterContext.Consumer>\n        )\n    }\n}\n\nclass Link extends Component {\n    handleClick = (event, history) => {\n        event.preventDefault();\n        history.push(this.props.to);\n    }\n\n    render() {\n        const { to, children } = this.props;\n        return (\n            <RouterContext.Consumer>{\n                context => {\n                    return <a href={to} onClick={(event) => this.handleClick(event, context.history)}>{children}</a>\n                }    \n            }</RouterContext.Consumer>\n        )\n    }\n}\n\nclass Switch extends Component {\n    render() {\n        return <RouterContext.Consumer>\n            {\n                context => {\n                    const location = this.props.location || context.location;\n                    let element, match;\n                    // 拿出传入children\n                    const { children } = this.props;\n                    // 遍历查找第一个匹配得到的元素 也就是match不存在并且是合法dom\n                    React.Children.forEach(children, child => {\n                        if (match == null && React.isValidElement(child)) {\n                            element = child;\n                            const path = child.props.path;\n                            match = context.match ? context.match \n                                : path ? matchPath(location.pathname, {...child.props, path})\n                                : null;\n                        }\n                    });\n                    return match ? React.cloneElement(element, { location, computeMatch: match }) : null\n                }\n            }\n        </RouterContext.Consumer>\n    }\n}\n\nclass Redirect extends Component {\n    render() {\n        return <RouterContext.Consumer>\n            {\n                context => {\n                    const { to } = this.props;\n                    const { history } = context;\n                    console.log('to', to);\n                    return <LifeCycle onMount={() => history.push(to)} />\n                }\n            }\n        </RouterContext.Consumer>\n    }\n}\n\nclass LifeCycle extends Component {\n    componentDidMount() {\n        if (this.props.onMount) {\n            this.props.onMount();\n        }\n    }\n\n    render() {\n        return null;\n    }\n}\n\nexport { BrowserRouter, Route, Link, Switch, Redirect };"]},"metadata":{},"sourceType":"module"}