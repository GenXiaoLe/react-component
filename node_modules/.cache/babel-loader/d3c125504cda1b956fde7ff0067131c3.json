{"ast":null,"code":"import pathToRegexp from \"path-to-regexp\";\nconst cache = {};\nconst cacheLimit = 10000;\nlet cacheCount = 0;\n\nfunction compilePath(path, options) {\n  const cacheKey = `${options.end}${options.strict}${options.sensitive}`;\n  const pathCache = cache[cacheKey] || (cache[cacheKey] = {});\n  if (pathCache[path]) return pathCache[path];\n  const keys = [];\n  const regexp = pathToRegexp(path, keys, options);\n  const result = {\n    regexp,\n    keys\n  };\n\n  if (cacheCount < cacheLimit) {\n    pathCache[path] = result;\n    cacheCount++;\n  }\n\n  return result;\n}\n/**\n * Public API for matching a URL pathname to a path.\n */\n\n\nfunction matchPath(pathname, options = {}) {\n  if (typeof options === \"string\" || Array.isArray(options)) {\n    options = {\n      path: options\n    };\n  }\n\n  const {\n    path,\n    exact = false,\n    strict = false,\n    sensitive = false\n  } = options;\n  const paths = [].concat(path);\n  return paths.reduce((matched, path) => {\n    if (!path && path !== \"\") return null;\n    if (matched) return matched;\n    const {\n      regexp,\n      keys\n    } = compilePath(path, {\n      end: exact,\n      strict,\n      sensitive\n    });\n    const match = regexp.exec(pathname);\n    if (!match) return null;\n    const [url, ...values] = match;\n    const isExact = pathname === url;\n    if (exact && !isExact) return null;\n    return {\n      path,\n      // the path used to match\n      url: path === \"/\" && url === \"\" ? \"/\" : url,\n      // the matched portion of the URL\n      isExact,\n      // whether or not we matched exactly\n      params: keys.reduce((memo, key, index) => {\n        memo[key.name] = values[index];\n        return memo;\n      }, {})\n    };\n  }, null);\n}\n\nexport default matchPath;","map":{"version":3,"sources":["/Users/hanyue/development/github/react-components/src/plugins/component/matchPath.js"],"names":["pathToRegexp","cache","cacheLimit","cacheCount","compilePath","path","options","cacheKey","end","strict","sensitive","pathCache","keys","regexp","result","matchPath","pathname","Array","isArray","exact","paths","concat","reduce","matched","match","exec","url","values","isExact","params","memo","key","index","name"],"mappings":"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","sourcesContent":["import pathToRegexp from \"path-to-regexp\";\n\nconst cache = {};\nconst cacheLimit = 10000;\nlet cacheCount = 0;\n\nfunction compilePath(path, options) {\n  const cacheKey = `${options.end}${options.strict}${options.sensitive}`;\n  const pathCache = cache[cacheKey] || (cache[cacheKey] = {});\n\n  if (pathCache[path]) return pathCache[path];\n\n  const keys = [];\n  const regexp = pathToRegexp(path, keys, options);\n  const result = { regexp, keys };\n\n  if (cacheCount < cacheLimit) {\n    pathCache[path] = result;\n    cacheCount++;\n  }\n\n  return result;\n}\n\n/**\n * Public API for matching a URL pathname to a path.\n */\nfunction matchPath(pathname, options = {}) {\n  if (typeof options === \"string\" || Array.isArray(options)) {\n    options = { path: options };\n  }\n\n  const { path, exact = false, strict = false, sensitive = false } = options;\n\n  const paths = [].concat(path);\n\n  return paths.reduce((matched, path) => {\n    if (!path && path !== \"\") return null;\n    if (matched) return matched;\n\n    const { regexp, keys } = compilePath(path, {\n      end: exact,\n      strict,\n      sensitive\n    });\n    const match = regexp.exec(pathname);\n\n    if (!match) return null;\n\n    const [url, ...values] = match;\n    const isExact = pathname === url;\n\n    if (exact && !isExact) return null;\n\n    return {\n      path, // the path used to match\n      url: path === \"/\" && url === \"\" ? \"/\" : url, // the matched portion of the URL\n      isExact, // whether or not we matched exactly\n      params: keys.reduce((memo, key, index) => {\n        memo[key.name] = values[index];\n        return memo;\n      }, {})\n    };\n  }, null);\n}\n\nexport default matchPath;\n"]},"metadata":{},"sourceType":"module"}