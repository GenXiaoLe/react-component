{"ast":null,"code":"export function createStore(reduce, enhancer) {\n  if (enhancer) {\n    return enhancer(createStore)(reduce);\n  }\n\n  let currentState = undefined;\n  let currentListeners = []; // 获取state\n\n  function getState() {\n    return currentState;\n  } // 更新数据\n\n\n  function dispatch(action) {\n    currentState = reduce(currentState, action);\n    currentListeners.forEach(cb => {\n      cb();\n    });\n  } // 监听数据\n\n\n  function subscribe(listener) {\n    currentListeners.push(listener);\n  } // 获取初始值\n\n\n  dispatch('init');\n  return {\n    getState,\n    dispatch,\n    subscribe\n  };\n}\nexport function applyMiddleware(...middlewares) {\n  // 由于dispatch不能处理函数，需要通过中间件获得处理后的强化版dispatch，所以需要通过链式调用将基础参数注入中间件并得到最后的dispatch\n  // 1 applyMiddleware() 返回 \n  // createStore => (...args) => {\n  //     const store = createStore(...args);\n  //     return {\n  //         ...store\n  //     };\n  // }\n  // 2 enhancer(createStore) 返回\n  // (...args) => {\n  //     const store = createStore(...args);\n  //     return {\n  //         ...store\n  //     };\n  // }\n  // 3 enhancer(createStore)(reduce) 返回\n  // return {\n  //     ...store\n  // };\n  // createStore === createStore ...args === reduce\n  return createStore => (...args) => {\n    const store = createStore(...args); // 依靠中间件获得加强版的dispatch\n    // 获取基础的dispatch\n\n    let dispatch = store.dispatch; // 中间件运行过程\n    // 1. 调用中间件，注入基础参数 getState, dispatch\n\n    let middlewareApi = {\n      getState: store.getState,\n      dispatch\n    }; // 2. 循环中间件，或得注入参数后的中间件，得到中间件数组\n\n    const middlewaresChain = middlewares.map(middleware => middleware(middlewareApi)); // middleware(middlewareApi) 返回\n    // dispatch => action => {\n    //     console.log(`${action.type}执行了`);\n    //     return dispatch(action);\n    // }\n    // 3. 由于那个中间件都需要用到上次一处理后的数据，middlewaresChain需要实现链式调用，并拿到最后中间件处理过后的dispatch\n\n    dispatch = compose(...middlewaresChain)(dispatch); // 返回\n    // action => {\n    //     console.log(`${action.type}执行了`);\n    //     return dispatch(action);\n    // }\n    // 此时的dispatch已经包了一层或者多层，可以链式调用，相当于加强版的dispatch，调用dispatch都会走这里\n    // 4. 得到强化后的dispatch 替换掉基础的dispatch\n\n    return { ...store,\n      dispatch\n    };\n  };\n} // 返回链式调用嵌套函数\n\nfunction compose(...funcs) {\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}","map":{"version":3,"sources":["/Users/hanyue/development/github/react-components/src/plugins/KRedux.js"],"names":["createStore","reduce","enhancer","currentState","undefined","currentListeners","getState","dispatch","action","forEach","cb","subscribe","listener","push","applyMiddleware","middlewares","args","store","middlewareApi","middlewaresChain","map","middleware","compose","funcs","a","b"],"mappings":"AAAA,OAAO,SAASA,WAAT,CAAqBC,MAArB,EAA6BC,QAA7B,EAAuC;AAC1C,MAAIA,QAAJ,EAAc;AACV,WAAOA,QAAQ,CAACF,WAAD,CAAR,CAAsBC,MAAtB,CAAP;AACH;;AAED,MAAIE,YAAY,GAAGC,SAAnB;AACA,MAAIC,gBAAgB,GAAG,EAAvB,CAN0C,CAQ1C;;AACA,WAASC,QAAT,GAAoB;AAChB,WAAOH,YAAP;AACH,GAXyC,CAa1C;;;AACA,WAASI,QAAT,CAAkBC,MAAlB,EAA0B;AACtBL,IAAAA,YAAY,GAAGF,MAAM,CAACE,YAAD,EAAeK,MAAf,CAArB;AAEAH,IAAAA,gBAAgB,CAACI,OAAjB,CAAyBC,EAAE,IAAI;AAC3BA,MAAAA,EAAE;AACL,KAFD;AAGH,GApByC,CAsB1C;;;AACA,WAASC,SAAT,CAAmBC,QAAnB,EAA6B;AACzBP,IAAAA,gBAAgB,CAACQ,IAAjB,CAAsBD,QAAtB;AACH,GAzByC,CA2B1C;;;AACAL,EAAAA,QAAQ,CAAC,MAAD,CAAR;AAEA,SAAO;AACHD,IAAAA,QADG;AAEHC,IAAAA,QAFG;AAGHI,IAAAA;AAHG,GAAP;AAKH;AAED,OAAO,SAASG,eAAT,CAAyB,GAAGC,WAA5B,EAAyC;AAC5C;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA,SAAOf,WAAW,IAAI,CAAC,GAAGgB,IAAJ,KAAa;AAC/B,UAAMC,KAAK,GAAGjB,WAAW,CAAC,GAAGgB,IAAJ,CAAzB,CAD+B,CAG/B;AAEA;;AACA,QAAIT,QAAQ,GAAGU,KAAK,CAACV,QAArB,CAN+B,CAQ/B;AACA;;AACA,QAAIW,aAAa,GAAG;AAChBZ,MAAAA,QAAQ,EAAEW,KAAK,CAACX,QADA;AAEhBC,MAAAA;AAFgB,KAApB,CAV+B,CAe/B;;AACA,UAAMY,gBAAgB,GAAGJ,WAAW,CAACK,GAAZ,CAAgBC,UAAU,IAAIA,UAAU,CAACH,aAAD,CAAxC,CAAzB,CAhB+B,CAiB/B;AACA;AACA;AACA;AACA;AAEA;;AACAX,IAAAA,QAAQ,GAAGe,OAAO,CAAC,GAAGH,gBAAJ,CAAP,CAA6BZ,QAA7B,CAAX,CAxB+B,CAyB/B;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA,WAAO,EACH,GAAGU,KADA;AAEHV,MAAAA;AAFG,KAAP;AAIH,GArCD;AAsCH,C,CAED;;AACA,SAASe,OAAT,CAAiB,GAAGC,KAApB,EAA2B;AACvB,SAAOA,KAAK,CAACtB,MAAN,CAAa,CAACuB,CAAD,EAAIC,CAAJ,KAAU,CAAC,GAAGT,IAAJ,KAAaQ,CAAC,CAACC,CAAC,CAAC,GAAGT,IAAJ,CAAF,CAArC,CAAP;AACH","sourcesContent":["export function createStore(reduce, enhancer) {\n    if (enhancer) {\n        return enhancer(createStore)(reduce);\n    }\n\n    let currentState = undefined;\n    let currentListeners = [];\n\n    // 获取state\n    function getState() {\n        return currentState;\n    }\n\n    // 更新数据\n    function dispatch(action) {\n        currentState = reduce(currentState, action);\n\n        currentListeners.forEach(cb => {\n            cb();\n        })\n    }\n\n    // 监听数据\n    function subscribe(listener) {\n        currentListeners.push(listener);\n    }\n\n    // 获取初始值\n    dispatch('init');\n\n    return {\n        getState,\n        dispatch,\n        subscribe\n    };\n}\n\nexport function applyMiddleware(...middlewares) {\n    // 由于dispatch不能处理函数，需要通过中间件获得处理后的强化版dispatch，所以需要通过链式调用将基础参数注入中间件并得到最后的dispatch\n\n    // 1 applyMiddleware() 返回 \n    // createStore => (...args) => {\n    //     const store = createStore(...args);\n    //     return {\n    //         ...store\n    //     };\n    // }\n\n    // 2 enhancer(createStore) 返回\n    // (...args) => {\n    //     const store = createStore(...args);\n    //     return {\n    //         ...store\n    //     };\n    // }\n\n    // 3 enhancer(createStore)(reduce) 返回\n    // return {\n    //     ...store\n    // };\n\n    // createStore === createStore ...args === reduce\n    return createStore => (...args) => {\n        const store = createStore(...args);\n\n        // 依靠中间件获得加强版的dispatch\n\n        // 获取基础的dispatch\n        let dispatch = store.dispatch;\n\n        // 中间件运行过程\n        // 1. 调用中间件，注入基础参数 getState, dispatch\n        let middlewareApi = {\n            getState: store.getState,\n            dispatch\n        };\n\n        // 2. 循环中间件，或得注入参数后的中间件，得到中间件数组\n        const middlewaresChain = middlewares.map(middleware => middleware(middlewareApi));\n        // middleware(middlewareApi) 返回\n        // dispatch => action => {\n        //     console.log(`${action.type}执行了`);\n        //     return dispatch(action);\n        // }\n\n        // 3. 由于那个中间件都需要用到上次一处理后的数据，middlewaresChain需要实现链式调用，并拿到最后中间件处理过后的dispatch\n        dispatch = compose(...middlewaresChain)(dispatch);\n        // 返回\n        // action => {\n        //     console.log(`${action.type}执行了`);\n        //     return dispatch(action);\n        // }\n        // 此时的dispatch已经包了一层或者多层，可以链式调用，相当于加强版的dispatch，调用dispatch都会走这里\n\n        // 4. 得到强化后的dispatch 替换掉基础的dispatch\n        return {\n            ...store,\n            dispatch\n        };\n    }\n}\n\n// 返回链式调用嵌套函数\nfunction compose(...funcs) {\n    return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n\n"]},"metadata":{},"sourceType":"module"}