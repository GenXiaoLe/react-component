{"ast":null,"code":"// vode => dom\n// render 接收vnode和传入的插入父节点 返回真实dom\n// 实现fiber\n// fiber tree数据结构是一种链表结构 除了常规的type props值。具体还有node(真实节点) child(第一个子元素) sibling(第一个子元素的下一个元素) base(上次的fiber节点 用于diff对比)\n// 1. 定义一个nextUnitOfWork，表示下一个任务单元，改造render方法 render方法接收最外层vnode tree，需要创建一个根fiber，并将其写入下一个任务单元，开启执行\n// 2. 使用调度栈方法requestIdleCallback，他可以自行分配任务时间，决定任务执行，我们只需把调度每个任务的方法或者diff传进去\n// 3. 创建调度任务方法workLoop\n// 4. workLoop写一个执行任务方法 performUnitOfWork 返回下一个任务nextUnitOfWork方便继续执行\n// 5. performUnitOfWork 执行当前任务 根据type类型 执行不同的方法 目的是生成当前fiber的真实dom 并且向下构建子元素的fiber结构\n// 6. 调用_createNode或者其它方式 生成当前fiber的真实dom 存在node属性中\n// 7. 调用reconcilerChildren 生成子元素的fiber结构 这里主要循环遍历所有子元素 根据元素的是否是同一个元素 判断需要更新还是创建fiber 还是删除 打上相应tags 并形成fiber链表结构方便之后调用\n// 8. performUnitOfWork 执行完当前任务 返回下一个任务 原则是先找子节点 如果没有去找兄弟节点 没有返回父节点在找兄弟节点 反复此步骤 直到所有节点均查找完毕 返回false\n// 9. workLoop写一个任务结束后提交任务，执行渲染的方法commitRoot 目的是当所有单元任务均执行完毕之后 统一提交进行更新渲染 插入相应dom中完成更新\n// 10. commitWorker方法用来提交单元任务 第一次接收根fiber\n// 11. 先找到父节点 方便之后创建或更新使用，根据之前fiber中的tags 创建元素 或 更新元素 或 删除元素，实行完当前的元素操作 对他的child和sibling也进行commitWorker\n// 12. 最后在fiber不存在时候表明所有元素均执行完毕 至此fiber diff 以及 渲染全部结束\n// 写一个数据演示fiber结构\n// {\n//     type: 'element',\n//     node: '<div id=\"root\"></div>',\n//     base: null,\n//     props: {},\n//     parent: null,\n//     child: {\n//         type: 'element',\n//         node: '<p></p>',\n//         base: null,\n//         props: {},\n//         parent: '<div id=\"root\"></div>',\n//         child: {\n//             type: 'TEXT'\n//         }\n//     },\n//     sibling: {\n//         type: 'element',\n//         node: '<p></p>',\n//         base: null,\n//         props: {},\n//         parent: '<div id=\"root\"></div>',\n//         child: {\n//             type: 'TEXT'\n//         }\n//     }\n// }\nimport { UPDATE, PLACEMENT } from \"./CONSTS\"; // 表示下一个单元任务\n\nlet nextUnitOfWork; // 表示根fiber\n\nlet rootFiber; // 表示当前的根节点\n\nlet currentRoot; // 虚拟dom转化为真实dom\n\nfunction render(vnode, container) {\n  // 创建根fiber\n  rootFiber = {\n    node: container,\n    props: {\n      children: [vnode]\n    },\n    base: currentRoot\n  }; // 赋值给下一个任务单元 以开启任务执行\n\n  nextUnitOfWork = rootFiber;\n} // 创建class节点\n\n\nfunction _createComNode({\n  type,\n  props\n}) {\n  let comp = new type(props);\n  let vvnode = comp.render();\n\n  let vnode = _createNode(vvnode);\n\n  return vnode;\n} // 创建function节点\n\n\nfunction _createFnNode({\n  type,\n  props\n}) {\n  let vvnode = type(props);\n\n  let vnode = _createNode(vvnode);\n\n  return vnode;\n} // 创建节点\n\n\nfunction _createNode(vnode) {\n  const {\n    type,\n    props\n  } = vnode;\n  let node; // 如果vnode是文本节点\n\n  if (type === 'Text') {\n    node = document.createTextNode('');\n  } else if (typeof type === 'function') {\n    // 如果是class组件节点\n    if (type.prototype.isReactComponent) {\n      node = _createComNode(vnode);\n    } else {\n      // 如果是function组件节点\n      node = _createFnNode(vnode);\n    }\n  } else if (type) {\n    // 如果是元素节点\n    node = document.createElement(type);\n  } else {\n    // 如果type是一个fragment\n    // document。createDocumentFragment 将文档碎片插入到父元素\n    node = document.createDocumentFragment();\n  } // 将属性填充进节点中\n\n\n  if (type) {\n    _updateNode(node, props);\n  } //由于存在children，所以需要递归\n\n\n  reconcilerChildren(props.children, node);\n  return node;\n} // 接收正在工作的fiber以及子节点数组 构建子节点fiber\n\n\nfunction reconcilerChildren(workInProgressFiber, children) {\n  // 上次的子fiber 用于判断是否是否是同一个fiber 来判断更新或者新增\n  let oldChildFiber = workInProgressFiber.base && workInProgressFiber.base.child;\n\n  for (let i = 0; i < children.length; i++) {\n    let child = children[i]; // 这里先不考虑key值\n\n    let isSameType = oldChildFiber && child && oldChildFiber.type === child.type;\n    let newFiber;\n\n    if (isSameType) {\n      // 相同打上更新的tags\n      newFiber = {};\n    } else if (child) {\n      // 相同打上新增的tags\n      newFiber = {\n        type: child.type,\n        props: child.props,\n        node: null,\n        // 新增的fiber没有真实dom\n        base: null,\n        // 新增的fiber没有上次fiber\n        parent: workInProgressFiber,\n        effectTag: PLACEMENT // tags为新增\n\n      };\n    }\n  }\n} // 接收dom以及props，进行赋值\n\n\nfunction _updateNode(node, values) {\n  Object.keys(values).filter(item => item !== 'children').forEach(key => {\n    if (key.slice(0, 2) === 'on') {\n      let _typeName = key.slice(2).toLocaleLowerCase();\n\n      document.addEventListener(_typeName, values[key]);\n    } else {\n      node[key] = values[key];\n    }\n  });\n} // 根节点或者是Fragment\n\n\nfunction _createFragment(fiber) {\n  const {\n    children\n  } = fiber;\n  reconcilerChildren(fiber, children);\n} // 接收任务 并执行任务\n\n\nfunction performUnitOfWork(fiber) {\n  // 执行当前的任务\n  const {\n    type\n  } = fiber;\n\n  if (type) {} else {\n    // 如果没有type\n    _createFragment(fiber);\n  }\n} // 创建任务调度方法 调度diff或者是渲染任务 接收一个传入的deadline值 表示任务剩余时间\n\n\nfunction workLoop(deadline) {\n  // 循环调度执行所有任务 规则是有下一个人物并且循环时间尚未结束\n  while (nextUnitOfWork && deadline.timeRemaining() > 1) {\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n  }\n}\n\nrequestIdleCallback(workLoop);\nexport default {\n  render\n};","map":{"version":3,"sources":["/Users/hanyue/development/github/react-components/src/plugins/KReactDOM.fiber.js"],"names":["UPDATE","PLACEMENT","nextUnitOfWork","rootFiber","currentRoot","render","vnode","container","node","props","children","base","_createComNode","type","comp","vvnode","_createNode","_createFnNode","document","createTextNode","prototype","isReactComponent","createElement","createDocumentFragment","_updateNode","reconcilerChildren","workInProgressFiber","oldChildFiber","child","i","length","isSameType","newFiber","parent","effectTag","values","Object","keys","filter","item","forEach","key","slice","_typeName","toLocaleLowerCase","addEventListener","_createFragment","fiber","performUnitOfWork","workLoop","deadline","timeRemaining","requestIdleCallback"],"mappings":"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","sourcesContent":["// vode => dom\n// render 接收vnode和传入的插入父节点 返回真实dom\n\n// 实现fiber\n// fiber tree数据结构是一种链表结构 除了常规的type props值。具体还有node(真实节点) child(第一个子元素) sibling(第一个子元素的下一个元素) base(上次的fiber节点 用于diff对比)\n// 1. 定义一个nextUnitOfWork，表示下一个任务单元，改造render方法 render方法接收最外层vnode tree，需要创建一个根fiber，并将其写入下一个任务单元，开启执行\n// 2. 使用调度栈方法requestIdleCallback，他可以自行分配任务时间，决定任务执行，我们只需把调度每个任务的方法或者diff传进去\n// 3. 创建调度任务方法workLoop\n// 4. workLoop写一个执行任务方法 performUnitOfWork 返回下一个任务nextUnitOfWork方便继续执行\n// 5. performUnitOfWork 执行当前任务 根据type类型 执行不同的方法 目的是生成当前fiber的真实dom 并且向下构建子元素的fiber结构\n// 6. 调用_createNode或者其它方式 生成当前fiber的真实dom 存在node属性中\n// 7. 调用reconcilerChildren 生成子元素的fiber结构 这里主要循环遍历所有子元素 根据元素的是否是同一个元素 判断需要更新还是创建fiber 还是删除 打上相应tags 并形成fiber链表结构方便之后调用\n// 8. performUnitOfWork 执行完当前任务 返回下一个任务 原则是先找子节点 如果没有去找兄弟节点 没有返回父节点在找兄弟节点 反复此步骤 直到所有节点均查找完毕 返回false\n// 9. workLoop写一个任务结束后提交任务，执行渲染的方法commitRoot 目的是当所有单元任务均执行完毕之后 统一提交进行更新渲染 插入相应dom中完成更新\n// 10. commitWorker方法用来提交单元任务 第一次接收根fiber\n// 11. 先找到父节点 方便之后创建或更新使用，根据之前fiber中的tags 创建元素 或 更新元素 或 删除元素，实行完当前的元素操作 对他的child和sibling也进行commitWorker\n// 12. 最后在fiber不存在时候表明所有元素均执行完毕 至此fiber diff 以及 渲染全部结束\n\n// 写一个数据演示fiber结构\n// {\n//     type: 'element',\n//     node: '<div id=\"root\"></div>',\n//     base: null,\n//     props: {},\n//     parent: null,\n//     child: {\n//         type: 'element',\n//         node: '<p></p>',\n//         base: null,\n//         props: {},\n//         parent: '<div id=\"root\"></div>',\n//         child: {\n//             type: 'TEXT'\n//         }\n//     },\n//     sibling: {\n//         type: 'element',\n//         node: '<p></p>',\n//         base: null,\n//         props: {},\n//         parent: '<div id=\"root\"></div>',\n//         child: {\n//             type: 'TEXT'\n//         }\n//     }\n// }\n\nimport {UPDATE, PLACEMENT} from \"./CONSTS\";\n\n// 表示下一个单元任务\nlet nextUnitOfWork;\n// 表示根fiber\nlet rootFiber;\n// 表示当前的根节点\nlet currentRoot;\n\n// 虚拟dom转化为真实dom\nfunction render(vnode, container) {\n    // 创建根fiber\n    rootFiber = {\n        node: container,\n        props: {children: [vnode]},\n        base: currentRoot,\n    }\n    // 赋值给下一个任务单元 以开启任务执行\n    nextUnitOfWork = rootFiber;\n}\n\n// 创建class节点\nfunction _createComNode({ type, props }) {\n    let comp = new type(props);\n    let vvnode = comp.render();\n    let vnode = _createNode(vvnode);\n    return vnode;\n}\n\n// 创建function节点\nfunction _createFnNode({ type, props }) {\n    let vvnode = type(props);\n    let vnode = _createNode(vvnode);\n    return vnode;\n}\n\n// 创建节点\nfunction _createNode(vnode) {\n    const { type, props } = vnode;\n    let node;\n    // 如果vnode是文本节点\n    if (type === 'Text') {\n        node = document.createTextNode('');\n    } else if (typeof type === 'function') {\n        // 如果是class组件节点\n        if (type.prototype.isReactComponent) {\n           node =  _createComNode(vnode);\n        } else {\n            // 如果是function组件节点\n            node = _createFnNode(vnode);\n        }\n    } else if (type) {\n        // 如果是元素节点\n        node = document.createElement(type);\n    } else {\n        // 如果type是一个fragment\n        // document。createDocumentFragment 将文档碎片插入到父元素\n        node = document.createDocumentFragment();\n    }\n\n    // 将属性填充进节点中\n    if (type) {\n        _updateNode(node, props);\n    }\n    \n    //由于存在children，所以需要递归\n    reconcilerChildren(props.children, node);\n\n    return node;\n}\n\n// 接收正在工作的fiber以及子节点数组 构建子节点fiber\nfunction reconcilerChildren(workInProgressFiber, children) {\n    // 上次的子fiber 用于判断是否是否是同一个fiber 来判断更新或者新增\n    let oldChildFiber =  workInProgressFiber.base && workInProgressFiber.base.child;\n\n    for (let i = 0; i < children.length; i++) {\n        let child = children[i];\n        // 这里先不考虑key值\n        let isSameType = oldChildFiber && child && oldChildFiber.type === child.type;\n\n        let newFiber;\n        if (isSameType) {\n            // 相同打上更新的tags\n            newFiber = {\n\n            }\n        } else if (child) {\n            // 相同打上新增的tags\n            newFiber = {\n                type: child.type,\n                props: child.props,\n                node: null, // 新增的fiber没有真实dom\n                base: null, // 新增的fiber没有上次fiber\n                parent: workInProgressFiber,\n                effectTag: PLACEMENT // tags为新增\n            }\n        }\n    }\n}\n\n// 接收dom以及props，进行赋值\nfunction _updateNode(node, values) {\n    Object.keys(values)\n        .filter(item => item !== 'children')\n        .forEach(key => {\n            if (key.slice(0, 2) === 'on') {\n                let _typeName = key.slice(2).toLocaleLowerCase();\n                document.addEventListener(_typeName, values[key]);\n            } else {\n                node[key] = values[key];\n            }\n        })\n}\n\n// 根节点或者是Fragment\nfunction _createFragment(fiber) {\n    const { children } = fiber;\n    reconcilerChildren(fiber, children);\n}\n\n// 接收任务 并执行任务\nfunction performUnitOfWork(fiber) {\n    // 执行当前的任务\n    const { type } = fiber;\n\n    if (type) {\n\n    } else {\n        // 如果没有type\n        _createFragment(fiber)\n    }\n}\n\n\n// 创建任务调度方法 调度diff或者是渲染任务 接收一个传入的deadline值 表示任务剩余时间\nfunction workLoop(deadline) {\n    // 循环调度执行所有任务 规则是有下一个人物并且循环时间尚未结束\n    while(nextUnitOfWork && deadline.timeRemaining() > 1) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n}\n\nrequestIdleCallback(workLoop);\n\nexport default {\n    render\n}"]},"metadata":{},"sourceType":"module"}