{"ast":null,"code":"var _jsxFileName = \"/Users/hanyue/development/github/react-components/src/plugins/KReduxReact.js\";\nimport React, { Component } from 'react'; // 构建组件Provider以及方法connect\n// 实现provide\n// 1.Provider中注入store connect中均能接受到store 所以需要使用React.createContext\n// 2.构建React.createContext\n// 3.使用createContext的Provider注入props.store\n\nconst ValueContext = React.createContext();\nexport class Provider extends Component {\n  render() {\n    const {\n      store,\n      children\n    } = this.props;\n    return React.createElement(ValueContext.Provider, {\n      value: store,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 15\n      },\n      __self: this\n    }, children);\n  }\n\n} // 实现connect\n// 1.接收注入的上下文context中的stroe\n// 第一次调用接收两个参数 返回一个高阶函数\n// 2.接收第一个参数是mapStateToProps 这是一个函数 传入参数store 返回值接收一个sotre\n// 3.接收第二个参数是mapDispatchToProps 这也是一个函数 传入dispatch \n// 第二次调用接收一个外部组件 返回一个包装过后的组件\n// 4.在高阶函数WarpComponents中 需要把store和dispatch当作props传入\n\nexport const connect = (mapStateToProps = state => state, mapDispatchToProps) => WarpComponents => {\n  var _class, _temp;\n\n  return _temp = _class = class WarpComponent extends Component {\n    // 接收上下文ValueContext\n    constructor(props) {\n      super(props);\n\n      this.update = () => {\n        const {\n          getState,\n          dispatch\n        } = this.context;\n        const stateProps = mapStateToProps(getState());\n        const dispatchProps = {\n          dispatch\n        };\n        this.setState({\n          props: { ...stateProps,\n            ...dispatchProps\n          }\n        });\n      };\n\n      this.state = {\n        props: {}\n      };\n    } // 由于需要监听 在改变state的时候重新setState 所以需要update函数\n\n\n    componentDidMount() {\n      const {\n        subscribe\n      } = this.context;\n      subscribe(() => {\n        this.update();\n      });\n    }\n\n    render() {\n      return React.createElement(WarpComponents, Object.assign({}, this.state.props, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 67\n        },\n        __self: this\n      }));\n    }\n\n  }, _class.contextType = ValueContext, _temp;\n};","map":{"version":3,"sources":["/Users/hanyue/development/github/react-components/src/plugins/KReduxReact.js"],"names":["React","Component","ValueContext","createContext","Provider","render","store","children","props","connect","mapStateToProps","state","mapDispatchToProps","WarpComponents","WarpComponent","constructor","update","getState","dispatch","context","stateProps","dispatchProps","setState","componentDidMount","subscribe","contextType"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC,C,CACA;AAEA;AACA;AACA;AACA;;AAEA,MAAMC,YAAY,GAAGF,KAAK,CAACG,aAAN,EAArB;AAEA,OAAO,MAAMC,QAAN,SAAuBH,SAAvB,CAAiC;AACpCI,EAAAA,MAAM,GAAG;AACL,UAAM;AAAEC,MAAAA,KAAF;AAASC,MAAAA;AAAT,QAAsB,KAAKC,KAAjC;AACA,WACI,oBAAC,YAAD,CAAc,QAAd;AAAuB,MAAA,KAAK,EAAEF,KAA9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACKC,QADL,CADJ;AAKH;;AARmC,C,CAWxC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAME,OAAO,GAAG,CACnBC,eAAe,GAAGC,KAAK,IAAIA,KADR,EAEnBC,kBAFmB,KAGlBC,cAAc,IAAI;AAAA;;AACnB,0BAAO,MAAMC,aAAN,SAA4Bb,SAA5B,CAAsC;AACzC;AAGAc,IAAAA,WAAW,CAACP,KAAD,EAAQ;AACf,YAAMA,KAAN;;AADe,WAQnBQ,MARmB,GAQV,MAAM;AACX,cAAM;AAAEC,UAAAA,QAAF;AAAYC,UAAAA;AAAZ,YAAyB,KAAKC,OAApC;AACA,cAAMC,UAAU,GAAGV,eAAe,CAACO,QAAQ,EAAT,CAAlC;AACA,cAAMI,aAAa,GAAG;AAAEH,UAAAA;AAAF,SAAtB;AAEA,aAAKI,QAAL,CAAc;AACVd,UAAAA,KAAK,EAAE,EACH,GAAGY,UADA;AAEH,eAAGC;AAFA;AADG,SAAd;AAMH,OAnBkB;;AAEf,WAAKV,KAAL,GAAa;AACTH,QAAAA,KAAK,EAAE;AADE,OAAb;AAGH,KATwC,CAWzC;;;AAcAe,IAAAA,iBAAiB,GAAG;AAChB,YAAM;AAAEC,QAAAA;AAAF,UAAgB,KAAKL,OAA3B;AACAK,MAAAA,SAAS,CAAC,MAAM;AACZ,aAAKR,MAAL;AACH,OAFQ,CAAT;AAGH;;AAEDX,IAAAA,MAAM,GAAG;AACL,aACI,oBAAC,cAAD,oBAAoB,KAAKM,KAAL,CAAWH,KAA/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SADJ;AAGH;;AApCwC,GAA7C,SAEWiB,WAFX,GAEyBvB,YAFzB;AAsCH,CA1CM","sourcesContent":["import React, { Component } from 'react';\n// 构建组件Provider以及方法connect\n\n// 实现provide\n// 1.Provider中注入store connect中均能接受到store 所以需要使用React.createContext\n// 2.构建React.createContext\n// 3.使用createContext的Provider注入props.store\n\nconst ValueContext = React.createContext();\n\nexport class Provider extends Component {\n    render() {\n        const { store, children } = this.props;\n        return (\n            <ValueContext.Provider value={store}>\n                {children}\n            </ ValueContext.Provider>\n        )\n    }\n}\n\n// 实现connect\n// 1.接收注入的上下文context中的stroe\n// 第一次调用接收两个参数 返回一个高阶函数\n// 2.接收第一个参数是mapStateToProps 这是一个函数 传入参数store 返回值接收一个sotre\n// 3.接收第二个参数是mapDispatchToProps 这也是一个函数 传入dispatch \n// 第二次调用接收一个外部组件 返回一个包装过后的组件\n// 4.在高阶函数WarpComponents中 需要把store和dispatch当作props传入\nexport const connect = (\n    mapStateToProps = state => state,\n    mapDispatchToProps\n) => WarpComponents => {\n    return class WarpComponent extends Component {\n        // 接收上下文ValueContext\n        static contextType = ValueContext;\n\n        constructor(props) {\n            super(props);\n            this.state = {\n                props: {}\n            }\n        }\n\n        // 由于需要监听 在改变state的时候重新setState 所以需要update函数\n        update = () => {\n            const { getState, dispatch } = this.context;\n            const stateProps = mapStateToProps(getState())\n            const dispatchProps = { dispatch };\n\n            this.setState({\n                props: {\n                    ...stateProps,\n                    ...dispatchProps\n                }\n            })\n        }\n\n        componentDidMount() {\n            const { subscribe } = this.context;\n            subscribe(() => {\n                this.update();\n            })\n        }\n        \n        render() {\n            return (\n                <WarpComponents {...this.state.props} />\n            )\n        }\n    }\n}"]},"metadata":{},"sourceType":"module"}