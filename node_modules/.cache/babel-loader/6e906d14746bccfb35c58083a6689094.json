{"ast":null,"code":"import { PLACEMENT, UPDATE, DELETIONS } from \"../plugins/component/CONSTS\"; // todo 拓展视频 useState 实现update 以及 DELETIONS\n// 下一个子任务\n\nlet nextUnitOfWork = null; // work in progreess 工作中的fiber root\n\nlet wipRoot = null; // 现在的根节点\n\nlet currentRoot = null; // 当前正在工作的fiber\n\nlet wipFiber = null;\nlet hookIndex = null; // 存放删除fiber的数组, 最后提交的时候进行统一提交，不要忘记每次进行初始化\n\nlet deletions = null; // 初始化\n\nfunction render(vnode, container) {\n  wipRoot = {\n    node: container,\n    props: {\n      children: [vnode]\n    },\n    base: currentRoot\n  };\n  deletions = [];\n  nextUnitOfWork = wipRoot;\n} // 根据vnode，创建一个node\n\n\nfunction createNode(vnode) {\n  const {\n    type,\n    props\n  } = vnode;\n  let node;\n\n  if (type === \"TEXT\") {\n    node = document.createTextNode(\"\");\n  } else if (type) {\n    node = document.createElement(type);\n  }\n\n  updateNode(node, {}, props);\n  return node;\n} // 构建fiber结构，遍历workInProgressFiber的子节点\n\n\nfunction reconcilerChildren(workInProgressFiber, children) {\n  // 构建fiber结构\n  // 数组\n  // 更新  删除 新增\n  let prevSibling = null;\n  let oldFiber = workInProgressFiber.base && workInProgressFiber.base.child;\n\n  for (let i = 0; i < children.length; i++) {\n    let child = children[i];\n    let newFiber = null; // todo 比较 type key\n\n    const sameType = child && oldFiber && child.type === oldFiber.type;\n\n    if (sameType) {\n      // 复用 update\n      newFiber = {\n        type: oldFiber.type,\n        //类型 区分不同的fiber，比如说function class host等\n        props: child.props,\n        //属性参数等\n        node: oldFiber.node,\n        //真实dom节点\n        base: oldFiber,\n        //存储fiber，便于去比较\n        parent: workInProgressFiber,\n        effectTag: UPDATE\n      };\n    }\n\n    if (!sameType && child) {\n      newFiber = {\n        type: child.type,\n        //类型 区分不同的fiber，比如说function class host等\n        props: child.props,\n        //属性参数等\n        node: null,\n        //真实dom节点\n        base: null,\n        //存储fiber，便于去比较\n        parent: workInProgressFiber,\n        effectTag: PLACEMENT\n      };\n    }\n\n    if (!sameType && oldFiber) {\n      // todo  删除\n      // 有个删除数组， 每次push 打了删除tag的fiber进去，最后统一提交\n      oldFiber.effectTag = DELETIONS;\n      deletions.push(oldFiber);\n    }\n\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling;\n    } // parent\n    // child\n\n\n    if (i === 0) {\n      workInProgressFiber.child = newFiber;\n    } else {\n      prevSibling.sibling = newFiber; // sibling\n    }\n\n    prevSibling = newFiber;\n  }\n} // 更新节点上属性，如className、nodeValue等\n\n\nfunction updateNode(node, prevVal, nextVal) {\n  Object.keys(prevVal).filter(k => k !== \"children\").filter(k => !(k in nextVal)).forEach(k => {\n    if (k.slice(0, 2) === \"on\") {\n      // 以on开头，就认为是一个事件，源码处理复杂一些，\n      let eventName = k.slice(2).toLocaleLowerCase();\n      node.removeEventListener(eventName, prevVal[k]);\n    } else {\n      node[k] = \"\";\n    }\n  });\n  Object.keys(nextVal).filter(k => k !== \"children\").forEach(k => {\n    if (k.slice(0, 2) === \"on\") {\n      // 以on开头，就认为是一个事件，源码处理复杂一些，\n      let eventName = k.slice(2).toLocaleLowerCase();\n      node.addEventListener(eventName, nextVal[k]);\n    } else {\n      node[k] = nextVal[k];\n    }\n  });\n} // function组件，构建fiber\n\n\nfunction updateFunctionComponent(fiber) {\n  wipFiber = fiber;\n  wipFiber.hooks = [];\n  hookIndex = 0;\n  const {\n    type,\n    props\n  } = fiber;\n  const children = [type(props)];\n  reconcilerChildren(fiber, children);\n} // 更新class组件，构建fiber\n\n\nfunction updateClassComponent(fiber) {\n  const {\n    type,\n    props\n  } = fiber;\n  const cmp = new type(props);\n  const children = [cmp.render()];\n  reconcilerChildren(fiber, children);\n} // 原生标签，，构建fiber\n\n\nfunction updateHostComponent(fiber) {\n  if (!fiber.node) {\n    fiber.node = createNode(fiber);\n  }\n\n  const {\n    children\n  } = fiber.props;\n  reconcilerChildren(fiber, children);\n} // fragment标签，，构建fiber\n\n\nfunction updateFragmentComponent(fiber) {\n  const {\n    children\n  } = fiber.props;\n  reconcilerChildren(fiber, children);\n} // 执行当前任务，指定下一个任务，具体逻辑看下面实现及注释\n\n\nfunction performUnitOfWork(fiber) {\n  // 执行当前子任务\n  // todo\n  const {\n    type\n  } = fiber;\n\n  if (typeof type === \"function\") {\n    type.isReactComponent ? updateClassComponent(fiber) : updateFunctionComponent(fiber);\n  } else if (type) {\n    updateHostComponent(fiber);\n  } else {\n    updateFragmentComponent(fiber);\n  } // 返回下一个子任务\n  // 找到下个任务的原则：先找子元素\n\n\n  if (fiber.child) {\n    return fiber.child;\n  } // 如果没有子元素，寻找兄弟元素\n\n\n  let nextFiber = fiber;\n\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling;\n    }\n\n    nextFiber = nextFiber.parent;\n  } // return\n\n} // 看函数里具体注释\n\n\nfunction workLoop(deadline) {\n  // 执行子任务\n  // 返回下一个子任务\n  // ...\n  while (nextUnitOfWork && deadline.timeRemaining() > 1) {\n    //有下个子任务，并且当前帧还没有结束\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n  } // 没有子任务了，\n\n\n  if (!nextUnitOfWork && wipRoot) {\n    // 提交\n    // commit\n    commitRoot();\n  } // 提交\n\n\n  requestIdleCallback(workLoop);\n}\n\nrequestIdleCallback(workLoop); // 提交\n\nfunction commitRoot() {\n  deletions.forEach(commitWorker);\n  commitWorker(wipRoot.child);\n  currentRoot = wipRoot;\n  wipRoot = null;\n} // 提交具体的fiber执行\n\n\nfunction commitWorker(fiber) {\n  if (!fiber) {\n    return;\n  } // 向上查找\n\n\n  let parentNodeFiber = fiber.parent;\n\n  while (!parentNodeFiber.node) {\n    parentNodeFiber = parentNodeFiber.parent;\n  }\n\n  const parentNode = parentNodeFiber.node; // 更新 删除 新增\n\n  if (fiber.effectTag === PLACEMENT && fiber.node !== null) {\n    parentNode.appendChild(fiber.node);\n  } else if (fiber.effectTag === UPDATE && fiber.node !== null) {\n    updateNode(fiber.node, fiber.base.props, fiber.props);\n  } else if (fiber.effectTag === DELETIONS && fiber.node !== null) {\n    commitDeletions(fiber, parentNode);\n  }\n\n  commitWorker(fiber.child);\n  commitWorker(fiber.sibling);\n}\n\nfunction commitDeletions(fiber, parentNode) {\n  if (fiber.node) {\n    parentNode.removeChild(fiber.node);\n  } else {\n    commitDeletions(fiber.child, parentNode);\n  }\n} // init是初始值\n\n\nexport function useState(init) {\n  //新旧\n  const oldHook = wipFiber.base && wipFiber.base.hooks[hookIndex];\n  const hook = {\n    state: oldHook ? oldHook.state : init,\n    queue: []\n  };\n  const actions = oldHook ? oldHook.queue : [];\n  actions.forEach(action => {\n    hook.state = action;\n  });\n\n  const setState = action => {\n    hook.queue.push(action);\n    wipRoot = {\n      node: currentRoot.node,\n      props: currentRoot.props,\n      base: currentRoot\n    };\n    nextUnitOfWork = wipRoot;\n    deletions = [];\n  };\n\n  wipFiber.hooks.push(hook);\n  hookIndex++;\n  return [hook.state, setState];\n}\nexport default {\n  render\n};","map":{"version":3,"sources":["/Users/hanyue/development/github/react-components/src/plugins/KReactDOM.fiber.js"],"names":["PLACEMENT","UPDATE","DELETIONS","nextUnitOfWork","wipRoot","currentRoot","wipFiber","hookIndex","deletions","render","vnode","container","node","props","children","base","createNode","type","document","createTextNode","createElement","updateNode","reconcilerChildren","workInProgressFiber","prevSibling","oldFiber","child","i","length","newFiber","sameType","parent","effectTag","push","sibling","prevVal","nextVal","Object","keys","filter","k","forEach","slice","eventName","toLocaleLowerCase","removeEventListener","addEventListener","updateFunctionComponent","fiber","hooks","updateClassComponent","cmp","updateHostComponent","updateFragmentComponent","performUnitOfWork","isReactComponent","nextFiber","workLoop","deadline","timeRemaining","commitRoot","requestIdleCallback","commitWorker","parentNodeFiber","parentNode","appendChild","commitDeletions","removeChild","useState","init","oldHook","hook","state","queue","actions","action","setState"],"mappings":"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","sourcesContent":["import {PLACEMENT, UPDATE, DELETIONS} from \"../plugins/component/CONSTS\";\n// todo 拓展视频 useState 实现update 以及 DELETIONS\n\n// 下一个子任务\nlet nextUnitOfWork = null;\n// work in progreess 工作中的fiber root\nlet wipRoot = null;\n\n// 现在的根节点\nlet currentRoot = null;\n\n// 当前正在工作的fiber\nlet wipFiber = null;\nlet hookIndex = null;\n// 存放删除fiber的数组, 最后提交的时候进行统一提交，不要忘记每次进行初始化\nlet deletions = null;\n\n// 初始化\nfunction render(vnode, container) {\n  wipRoot = {\n    node: container,\n    props: {children: [vnode]},\n    base: currentRoot\n  };\n  deletions = [];\n  nextUnitOfWork = wipRoot;\n}\n\n// 根据vnode，创建一个node\nfunction createNode(vnode) {\n  const {type, props} = vnode;\n  let node;\n  if (type === \"TEXT\") {\n    node = document.createTextNode(\"\");\n  } else if (type) {\n    node = document.createElement(type);\n  }\n  updateNode(node, {}, props);\n  return node;\n}\n\n// 构建fiber结构，遍历workInProgressFiber的子节点\nfunction reconcilerChildren(workInProgressFiber, children) {\n  // 构建fiber结构\n  // 数组\n  // 更新  删除 新增\n  let prevSibling = null;\n  let oldFiber = workInProgressFiber.base && workInProgressFiber.base.child;\n  for (let i = 0; i < children.length; i++) {\n    let child = children[i];\n    let newFiber = null;\n    // todo 比较 type key\n    const sameType = child && oldFiber && child.type === oldFiber.type;\n    if (sameType) {\n      // 复用 update\n      newFiber = {\n        type: oldFiber.type, //类型 区分不同的fiber，比如说function class host等\n        props: child.props, //属性参数等\n        node: oldFiber.node, //真实dom节点\n        base: oldFiber, //存储fiber，便于去比较\n        parent: workInProgressFiber,\n        effectTag: UPDATE\n      };\n    }\n    if (!sameType && child) {\n      newFiber = {\n        type: child.type, //类型 区分不同的fiber，比如说function class host等\n        props: child.props, //属性参数等\n        node: null, //真实dom节点\n        base: null, //存储fiber，便于去比较\n        parent: workInProgressFiber,\n        effectTag: PLACEMENT\n      };\n    }\n    if (!sameType && oldFiber) {\n      // todo  删除\n      // 有个删除数组， 每次push 打了删除tag的fiber进去，最后统一提交\n      oldFiber.effectTag = DELETIONS;\n      deletions.push(oldFiber);\n    }\n\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling;\n    }\n    // parent\n    // child\n    if (i === 0) {\n      workInProgressFiber.child = newFiber;\n    } else {\n      prevSibling.sibling = newFiber;\n      // sibling\n    }\n    prevSibling = newFiber;\n  }\n}\n\n// 更新节点上属性，如className、nodeValue等\nfunction updateNode(node, prevVal, nextVal) {\n  Object.keys(prevVal)\n    .filter(k => k !== \"children\")\n    .filter(k => !(k in nextVal))\n    .forEach(k => {\n      if (k.slice(0, 2) === \"on\") {\n        // 以on开头，就认为是一个事件，源码处理复杂一些，\n        let eventName = k.slice(2).toLocaleLowerCase();\n        node.removeEventListener(eventName, prevVal[k]);\n      } else {\n        node[k] = \"\";\n      }\n    });\n\n  Object.keys(nextVal)\n    .filter(k => k !== \"children\")\n    .forEach(k => {\n      if (k.slice(0, 2) === \"on\") {\n        // 以on开头，就认为是一个事件，源码处理复杂一些，\n        let eventName = k.slice(2).toLocaleLowerCase();\n        node.addEventListener(eventName, nextVal[k]);\n      } else {\n        node[k] = nextVal[k];\n      }\n    });\n}\n\n// function组件，构建fiber\nfunction updateFunctionComponent(fiber) {\n  wipFiber = fiber;\n  wipFiber.hooks = [];\n  hookIndex = 0;\n  const {type, props} = fiber;\n  const children = [type(props)];\n  reconcilerChildren(fiber, children);\n}\n\n// 更新class组件，构建fiber\nfunction updateClassComponent(fiber) {\n  const {type, props} = fiber;\n  const cmp = new type(props);\n  const children = [cmp.render()];\n  reconcilerChildren(fiber, children);\n}\n\n// 原生标签，，构建fiber\nfunction updateHostComponent(fiber) {\n  if (!fiber.node) {\n    fiber.node = createNode(fiber);\n  }\n  const {children} = fiber.props;\n  reconcilerChildren(fiber, children);\n}\n\n// fragment标签，，构建fiber\nfunction updateFragmentComponent(fiber) {\n  const {children} = fiber.props;\n  reconcilerChildren(fiber, children);\n}\n\n// 执行当前任务，指定下一个任务，具体逻辑看下面实现及注释\nfunction performUnitOfWork(fiber) {\n  // 执行当前子任务\n  // todo\n  const {type} = fiber;\n  if (typeof type === \"function\") {\n    type.isReactComponent\n      ? updateClassComponent(fiber)\n      : updateFunctionComponent(fiber);\n  } else if (type) {\n    updateHostComponent(fiber);\n  } else {\n    updateFragmentComponent(fiber);\n  }\n  // 返回下一个子任务\n  // 找到下个任务的原则：先找子元素\n  if (fiber.child) {\n    return fiber.child;\n  }\n  // 如果没有子元素，寻找兄弟元素\n  let nextFiber = fiber;\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling;\n    }\n    nextFiber = nextFiber.parent;\n  }\n  // return\n}\n\n// 看函数里具体注释\nfunction workLoop(deadline) {\n  // 执行子任务\n  // 返回下一个子任务\n  // ...\n  while (nextUnitOfWork && deadline.timeRemaining() > 1) {\n    //有下个子任务，并且当前帧还没有结束\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n  }\n\n  // 没有子任务了，\n  if (!nextUnitOfWork && wipRoot) {\n    // 提交\n    // commit\n    commitRoot();\n  }\n  // 提交\n  requestIdleCallback(workLoop);\n}\n\nrequestIdleCallback(workLoop);\n\n// 提交\nfunction commitRoot() {\n  deletions.forEach(commitWorker);\n  commitWorker(wipRoot.child);\n  currentRoot = wipRoot;\n  wipRoot = null;\n}\n\n// 提交具体的fiber执行\nfunction commitWorker(fiber) {\n  if (!fiber) {\n    return;\n  }\n\n  // 向上查找\n  let parentNodeFiber = fiber.parent;\n  while (!parentNodeFiber.node) {\n    parentNodeFiber = parentNodeFiber.parent;\n  }\n  const parentNode = parentNodeFiber.node;\n  // 更新 删除 新增\n  if (fiber.effectTag === PLACEMENT && fiber.node !== null) {\n    parentNode.appendChild(fiber.node);\n  } else if (fiber.effectTag === UPDATE && fiber.node !== null) {\n    updateNode(fiber.node, fiber.base.props, fiber.props);\n  } else if (fiber.effectTag === DELETIONS && fiber.node !== null) {\n    commitDeletions(fiber, parentNode);\n  }\n  commitWorker(fiber.child);\n  commitWorker(fiber.sibling);\n}\n\nfunction commitDeletions(fiber, parentNode) {\n  if (fiber.node) {\n    parentNode.removeChild(fiber.node);\n  } else {\n    commitDeletions(fiber.child, parentNode);\n  }\n}\n\n// init是初始值\nexport function useState(init) {\n  //新旧\n  const oldHook = wipFiber.base && wipFiber.base.hooks[hookIndex];\n  const hook = {\n    state: oldHook ? oldHook.state : init,\n    queue: []\n  };\n\n  const actions = oldHook ? oldHook.queue : [];\n  actions.forEach(action => {\n    hook.state = action;\n  });\n  const setState = action => {\n    hook.queue.push(action);\n\n    wipRoot = {\n      node: currentRoot.node,\n      props: currentRoot.props,\n      base: currentRoot\n    };\n    nextUnitOfWork = wipRoot;\n    deletions = [];\n  };\n  wipFiber.hooks.push(hook);\n  hookIndex++;\n  return [hook.state, setState];\n}\n\nexport default {\n  render\n};\n"]},"metadata":{},"sourceType":"module"}